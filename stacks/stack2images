#!/usr/bin/python
#
# Copyright 2013 Hewlett-Packard Development Company, L.P.
# All Rights Reserved.
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

import argparse
import glanceclient
import json
import logging
import os
import subprocess
import sys
import yaml

METADATA_NAMESPACE = 'TripleO::ImageBuilder'
CONFIG_ELEMENT_MAP = {
    'Keystone': 'keystone',
    'Database': 'mysql',
}


class Run(object):
    noop = False

    @classmethod
    def cmd(cls, args):
        if cls.noop:
            print ' '.join(args)
        else:
            subprocess.check_call(args)


# Read stack
def read_stack(stack_path):
    with open(stack_path) as stack_file:
        try:
            stack = json.load(stack_file)
        except ValueError:
            stack_file.seek(0)
            try:
                stack = yaml.safe_load(stack_file)
            except yaml.parser.ParserError, e:
                logging.error(e)
                return False
    # Sanity checks
    if type(stack) != dict:
        logging.error(
                'Expecting map, instead got python type %s' % type(stack))
        return False
    if 'Resources' not in stack:
        logging.error('Stack has no resources')
    if 'Description' not in stack:
        logging.warn('Stack has no description')
    logging.info('Loaded %s (%s)' % (stack_path, stack.get('Description')))
    return stack


# Find metadata with TripleO::ImageBuilder::Elements
def find_element_metadata(stack):
    found = []
    for resource_key, resource in stack['Resources'].iteritems():
        resource_elements = set()
        logging.debug('Inspecting %s' % resource_key)
        metadata = resource.get('Metadata', {})
        for m_key, m_item in metadata.iteritems():
            logging.debug('Inspecting %s' % m_key)
            try:
                prefix, under = m_key.rsplit('::', 1)
            except ValueError:
                logging.debug('Ignoring %s->%s' % (resource_key, m_key))
                continue
            major, minor = prefix.split('::', 2)
            if minor in CONFIG_ELEMENT_MAP:
                resource_elements.add(CONFIG_ELEMENT_MAP[minor])
            if prefix != METADATA_NAMESPACE:
                logging.debug('Ignoring %s->%s [%s]'
                        % (resource_key, m_key, prefix))
                continue
            logging.debug('Found %s' % m_key)
            resource_elements.update(m_item)
            found.append(resource_elements)
    return found


# build image with said elements
def build_images(prefix, found, extra, use_existing):
    images = []
    for f in found:
        key = '-'.join(sorted(f))
        image_name = '%s%s' % (prefix, '-'.join(sorted(f)))
        images.append(image_name)
        image_file_name = '%s.qcow2' % image_name
        if os.path.exists(image_file_name) and use_existing:
            logging.info('Using existing image file %s' % image_file_name)
            continue
        command = ['disk-image-create', '-o', '%s' % image_name]
        command.extend(f)
        command.extend(extra)
        Run.cmd(command)
    return images


#   upload images
def upload_images(images, noop):
    for img in images:
        img_filename = '%s.qcow2' % img
        args = ['glance', 'image-create',
                    '--name', img,
                    '--public', '--container-format', 'bare',
                    '--disk-format', 'qcow2']
        if noop:
            print '%s < %s' % (' '.join(args), img_filename)
        else:
            with open(img_filename) as img_file:
                glance = subprocess.Popen(args, stdin=img_file)
                glance.wait()


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('stack_path',
            help='Stack to determine images from')
    parser.add_argument('--log-level', default='WARN',
            help='Basic root logging level')
    parser.add_argument('--extra', '-e', nargs='*', default=[],
            help='Extra elements to add')
    parser.add_argument('--prefix', '-p', default='image-',
            help='Prefix for image names')
    parser.add_argument('--noop', '-n', default=False, action='store_true',
            help='Just print actions instead of executing them.')
    parser.add_argument('--use-existing', default=False, action='store_true',
            help='Use any existing image files rather than building new ones.')
    options = parser.parse_args()

    logging.basicConfig(level=options.log_level)

    Run.noop = options.noop

    stack = read_stack(options.stack_path)
    if not stack:
        return 1

    found = find_element_metadata(stack)
    if found:
        images = build_images(options.prefix, found, options.extra, options.use_existing)
        if images:
            upload_images(images, options.noop)

    return 0

if __name__ == '__main__':
    sys.exit(main())


#     # Determine name from template?
